<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Aug 18 22:59:00 PDT 2006</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h2>Welcome to <a href="../classes/Starfish.html">Starfish</a></h2>
<p>
<a href="../classes/Starfish.html">Starfish</a> is a utility to make
distributed programming ridiculously easy.
</p>
<h2>Download</h2>
<ul>
<li>gem install starfish

</li>
<li><a
href="http://rubyforge.org/projects/starfish">rubyforge.org/projects/starfish</a>

</li>
<li>svn co svn://rubyforge.org//var/svn/starfish

</li>
</ul>
<h2>Background</h2>
<p>
<a href="../classes/Starfish.html">Starfish</a> was born by abstracting
code from a highly popular website (<a href="http://mog.com">mog.com</a>).
I had written distributed programming code for various tasks including
database corruption cleanup as well as real-time indexing requirements and
decided that nobody should have to write as much code as I did to do those
tasks. The general idea of distributed programming is vastly underused by
most programmers and <a href="../classes/Starfish.html">Starfish</a> hides
everything you don&#8217;t have to worry about.
</p>
<h2>Usage</h2>
<p>
Make a file and define the server and client. What follows is a simple
example:
</p>
<pre>
    # foo.rb
    class Foo
      attr_reader :i

      def initialize
        @i = 0
      end

      def inc
        logger.info &quot;YAY it incremented by 1 up to #{@i}&quot;
        @i += 1
      end
    end

    server do |object|
      object = Foo.new
    end

    client do |object|
      object.inc
    end
</pre>
<p>
Notice that you need not specify any network code, nor learn a foreign API
like DRb or Rinda. You need not even define logger, starfish takes care of
it for you at runtime. You just tell it how to serve an object and how to
process the object. To run this code, simply run:
</p>
<pre>
    starfish foo.rb
</pre>
<p>
This starts a server AND a client to start processing that object. The
client runs in a continuous loop. If you call starfish foo.rb subsequent
times from either the local machine or any machine on the local network,
more clients will start processing the server concurrently.
</p>
<p>
By default, the server will start a log file at /tmp/foo.rb.log. You can
override this behaviour.
</p>
<pre>
    server :log =&gt; &quot;/var/log/foo.log&quot; do |object|
      object = Foo.new
    end
</pre>
<p>
The :log parameter is intelligent and can take various other formats
including nil for no logging or instances of any kind of logger class you
prefer to use.
</p>
<h2><a href="../classes/MapReduce.html">MapReduce</a> with ActiveRecord</h2>
<p>
The crown jewel of <a href="../classes/Starfish.html">Starfish</a> is
actually a library built on <a href="../classes/Starfish.html">Starfish</a>
called <a href="../classes/MapReduce.html">MapReduce</a>. Inspired by
Google&#8217;s <a href="../classes/MapReduce.html">MapReduce</a> (<a
href="http://en.wikipedia.org/wiki/MapReduce">en.wikipedia.org/wiki/MapReduce</a>),
it automates the process of divide and conquer for large data sets.
Currently, <a href="../classes/Starfish.html">Starfish</a>&#8217;s
implementation only works with the ActiveRecord ORM from Ruby on Rails. The
idea is that you have a very large data set that would be unmanageable to
process otherwise. For example, let&#8217;s say your database table has
30GB of information in it. It would be very difficult to keep 30GB of
records in RAM at one time; even if you processed them serially, it would
take a very long time. The idea is to have many clients grabbing chunks of
the database at a time making much faster work, even on a single processor
machine, than would otherwise be feasible.
</p>
<p>
Here is the basic code that will get you up and running with <a
href="../classes/MapReduce.html">MapReduce</a> in <a
href="../classes/Starfish.html">Starfish</a>.
</p>
<pre>
    # item.rb
    ActiveRecord::Base.establish_connection(
      :adapter  =&gt; &quot;mysql&quot;,
      :host     =&gt; &quot;localhost&quot;,
      :username =&gt; &quot;root&quot;,
      :password =&gt; &quot;&quot;,
      :database =&gt; &quot;some_database&quot;
    )

    class Item &lt; ActiveRecord::Base; end

    server do |map_reduce|
      map_reduce.type = Item
    end

    client do |item|
      logger.info item.id
    end
</pre>
<p>
Just like the previous example, just run:
</p>
<pre>
    starfish item.rb
</pre>
<p>
<a href="../classes/Starfish.html">Starfish</a> takes care of the rest. The
code above does the following:
</p>
<ul>
<li>The server grabs all the items via: Item.find(:all)

</li>
<li>Each of the clients grab an item from the collection

</li>
<li>When there are no more items to be grabbed, everything shuts down

</li>
</ul>
<p>
However there are cases when you might want some fancier behaviour.
</p>
<pre>
    server do |map_reduce|
      map_reduce.type = Item
      map_reduce.conditions = [&quot;some_important_flag = ?&quot;, 1]
      map_reduce.vigilant = true
      map_reduce.queue_size = 1000
    end
</pre>
<p>
Here are three new options: conditions, vigilant, and queue_size.
Conditions simply limits what is grabbed via ActiveRecord. It is equivalent
to saying: Item.find(:all, :conditions =&gt; [&quot;some_important_flag =
?&quot;, 1]). Vigilant simply keeps the clients alive and when
Item.find(:all) runs out of items, it will vigilantly poll for newly
created items periodically. Queue size specifies the number of items
buffered in the server queue. In the case of the 30GB database table, you
do not want to grab all 30GB at once, instead you grab 1000 at a time as
needed by your clients.
</p>
<p>
Another options you have when you use the vigilant option is
map_reduce.empty_queue_wait which specifies how long to wait between polls
for new information.
</p>
<p>
There is yet a third main run-mode for <a
href="../classes/MapReduce.html">MapReduce</a> under ActiveRecord.
</p>
<pre>
    server do |map_reduce|
      map_reduce.type = Item
      map_reduce.rescan_when_complete = true
    end
</pre>
<p>
The events follow like this when the rescan_when_complete option is
enabled:
</p>
<ul>
<li>The server grabs all the items via: Item.find(:all)

</li>
<li>Each of the clients grab an item from the collection

</li>
<li>When there are no more items to be grabbed, the queue is re-filled via
Item.find(:all) and the process starts again

</li>
</ul>
<p>
If you need to continuously check over data for integrity, this option will
meet your demands.
</p>
<p>
Another bonus you get while using <a
href="../classes/MapReduce.html">MapReduce</a> is automatic statistics.
Simply call:
</p>
<pre>
    starfish item.rb stats
</pre>
<p>
And you will be returned a YAML hash of statistics.
</p>
<pre>
    ---
    time_spent_grabbing_objects: 0.090328
    time_spent_processing_objects: 0.023431
    time_began: 2006-08-16 09:30:32.926399 -07:00
    num_queues_grabbed: 5
    time_spent_grabbing_queues: 0.090328
    num_objects_grabbed: 10
</pre>
<h2><a href="../classes/MapReduce.html">MapReduce</a> with Files</h2>
<p>
You can also divide and conquer with files. The idea is that you have a
large file and want to process line-by-line as quickly as possible. It is
simple to accomplish this with <a
href="../classes/Starfish.html">Starfish</a>.
</p>
<pre>
    server do |map_reduce|
      map_reduce.type = File
      map_reduce.input = &quot;/tmp/big_log_file&quot;
    end

    client do |line|
      if line =~ /some_regex/
        logger.info(line)
      end
    end
</pre>
<p>
Simply replacing the type and input lets you process your file in a
distributed way. Like when using ActiveRecord, you also have options:
</p>
<pre>
    server do |map_reduce|
      map_reduce.type = File
      map_reduce.input = &quot;/tmp/big_log_file&quot;
      map_reduce.queue_size = 1000 # how many lines of the file to buffer at a time
      map_reduce.lines_per_client = 100 # how many lines each client will process at a time
      map_reduce.rescan_when_complete = true
    end
</pre>
<p>
For a file, rescan_when_complete goes back to the beginning of the file
when you have finished processing it. You can also use the vigilant option
to wait for new data to be added to the file.
</p>
<h2>Examples</h2>
<p>
See the examples/ directory.
</p>
<h2>Authors</h2>
<ul>
<li>Lucas Carlson from MOG (<a href="mailto:lucas@rufy.com">lucas@rufy.com</a>)
- <a href="http://mog.com">mog.com</a>

</li>
</ul>
<p>
This library is released under the terms of the BSD.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>